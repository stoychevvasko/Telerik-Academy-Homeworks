var allHomeworkTasks = [
    {
        'number': 1,
        'description': '<strong>Select 3 design patterns.</strong><br/><br/><ul><li>Write a short description (about half page) for each of them (prefer Bulgarian language)<ul><li>Describe their motivation, intent, applicability, known uses, implementation, consequences, structure, related patterns, etc.</li></ul></li><li>Provide C# examples for their use</li><li>Provide a UML diagram or image of the pattern<ul><li>You can download it from the Internet</li></ul></li></ul>',
        'link': 'solutions/task-01/task-01.html'
    },
];

var allBoxImages = [
    'resources/images/keyboard-glow.jpg',
    'resources/images/circuit-board.jpg',
    'resources/images/computer-code.jpg',
    'resources/images/cloud-computing.jpg',
    'resources/images/fiber-optics.jpg',
    'resources/images/circuit-brain.jpg',
    'resources/images/global-internet.jpg',
    'resources/images/shared-web.jpg',
    'resources/images/apps-globe.jpg',
];

var observerDescription = '<h3>Наблюдател (Observer)</h3><br/>Този design pattern се използва за дефиниране на зависимост (dependency) едно-към-много, така че когато един обект промени състоянието си, всички зависещи от него обекти получават съобщение и се обновяват (notification, update). Eдин субект може да бъде наблюдаван от множество наблюдатели. <br/><br/><strong>Наблюдателите (Observers)</strong> се регистрират към един или повече субекти (Subjects).<br/><br/> <strong>Субектите (Subjects)</strong> изпращат нотификация на наблюдателите (Observers).<br/><br/>Не е задължително субектът да има някаква връзка с наблюдателя, нито е необходимо да знае за съществуването на каквито и да е наблюдатели, които да следят промените идващи от субекта (events).<br/><br/>Design pattern Observer типично се ползва за двата типа съобщения - <em>нотификация (notification)</em> и <em>събитие (event)</em>.<br/><br/><strong>Съобщенията (Messages)</strong> могат да са всякакви, включително <em>събития (Events)</em>, <em>поисквания (Requests)</em>, <em>обновявания (Updates)</em> и <em>инструктции (Instructions).</em></br></br>Вместо да прилагаме <em>Observer Pattern</em> директно върху обекта на наблюдение, можем да ползваме <strong>Event Bus</strong>. Това е обект, към който множество наблюдатели са закачени и разпраща събития <em>(Events)</em>.<br/><br/><em>C# пример има във Visual Studio solution. </em><img src="../../resources/images/observer-diagram.png" alt="observer diagram" class="bgr-monocolor" id="observer-diagram"/>';

var builderDescription = '<h3>Билдър (Builder)</h3><br/>Използва се за отделяне на конструирането на комплексен обект от репрезентацията му, за да може с един и същи проект на конструкция да се създават различни репрезентации. Билдърът е динамичен начин, по който можем да създаваме продукт следвайки Composite Pattern.<br/><br/><strong>Клиентът (Client)</strong> използва <em>директора (Director).</em><br/><br/><strong>Методи от директора</strong> използват <em>Concrete Builder.</em> Той от своя страна конструира и връща обект по design pattern <em>Composite Object</em>.<br/><br/><strong>Composite Object</strong> се връща на <em>директора.</em><br/><br/><strong>Директорът (Director)</strong> връща обект на <em>клиента (Client).</em><br/><br/>Билдърът ни позволява да конструираме няколко версии на един и същи продукт чрез процеса <em>object composition.</em> С фиксиран брой вградени инструкции се постига вариращ резултат. Възможно е и класове в билдъра да имплементират инструкциите по различен начин, което води до еднакви по вид конструкции с напълно различна имплементация.<br/><br/><em>C# пример има във Visual Studio solution. </em><img src="../../resources/images/builder-design-pattern.png" alt="builder diagram" class="bgr-monocolor" id="builder-diagram"/>';

var parcerDescription = '<h3>Парсър (Parser)</h3><br/>Преобразува една структура в друга структура, като и двете съдържат подобна или идентична информация. Всяка структура може да бъде преобразувана в друга.<br/><br/><strong>Abstract Definition / Object Tree</strong> може да се парсне до <em>Abstract Definition</em> или <em>Object Tree / Composite Object.</em><br/><br/><strong>Abstract Definition</strong> може да се парсне към <em>Abstract Definition / Object Tree.</em><br/><br/><strong>Object Tree / Composite object</strong> може да се парсне към <em>Abstract Definition / Object Tree.</em><br/><br/>Парсърът може да се ползва за парсване или преобразуване на една структура в друга. Това може да е от XML към обект или от обект към XML, от XML към JSON и т.н. При преобваруването цялата информация се запазва непроменена по същество, но е организирана по нов начин. Счита се, че парсърът по подразбиране би трябвало да конвертира от всеки познат тип до всеки друг познат тип, доколкото това е възможно. Резултатите могат да бъдат подадени в парсъра отново и преобразувани в трета структура, като например Object Tree.<br/><br/>Парсването се дели на <em>lossful (със загуба на данни)</em> и <em>lossless (без загуба на данни).</em><img src="../../resources/images/parcer-design-pattern.png" alt="parcer diagram" class="bgr-monocolor" id="parcer-diagram"/>';